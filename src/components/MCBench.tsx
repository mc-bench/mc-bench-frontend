import { Suspense, useCallback, useEffect, useRef, useState } from 'react'

import { OrbitControls } from '@react-three/drei'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import {
  BookOpen,
  Code2,
  Flag,
  Loader2,
  Maximize2,
  Share2,
  Trophy,
} from 'lucide-react'
import * as THREE from 'three'

import { api } from '../api/client'
import { useAuth } from '../hooks/useAuth'
import {
  BuildPair,
  ComparisonBatchResponse,
  ComparisonResponse,
  MetricResponse,
  NewComparisonBatchRequest,
  QueuedComparison,
  UserComparisonRequest,
} from '../types/comparisons'
import AuthModal from './AuthModal'
import { Model, cleanupModel, modelPathCache, preloadModel } from './ModelUtils'
import Background from './background'

const UnauthenticatedView = () => {
  const [isAuthModalOpen, setIsAuthModalOpen] = useState(false)

  return (
    <div className="max-w-6xl mx-auto p-4 space-y-12">
      {/* Hero Section */}
      <div className="text-center space-y-6">
        <h1 className="text-4xl font-bold">Minecraft Benchmark</h1>
        <p className="text-xl text-gray-600 max-w-2xl mx-auto">
          Help advance AI research by comparing and rating Minecraft builds
          generated by different AI models
        </p>

        <div className="max-w-xl mx-auto bg-blue-50 p-6 rounded-lg">
          <h3 className="text-lg font-semibold text-blue-900 mb-2">
            Join Our Research Community
          </h3>
          <p className="text-blue-800 mb-4">
            Login to start rating builds and contribute to AI research in
            creative generation
          </p>
          <button
            onClick={() => setIsAuthModalOpen(true)}
            className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700"
          >
            Get Started
          </button>
        </div>
      </div>

      {/* Features */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        <div className="bg-white p-6 rounded-lg shadow-sm border">
          <div className="flex flex-col items-center mb-4">
            <Trophy className="h-10 w-10 text-yellow-500 mb-3" />
            <h3 className="text-xl font-semibold">Rate & Compare</h3>
          </div>
          <p className="text-gray-600 text-center">
            Compare AI-generated builds and help determine which models perform
            best
          </p>
        </div>

        <div className="bg-white p-6 rounded-lg shadow-sm border">
          <div className="flex flex-col items-center mb-4">
            <Code2 className="h-10 w-10 text-blue-500 mb-3" />
            <h3 className="text-xl font-semibold">Advance Research</h3>
          </div>
          <p className="text-gray-600 text-center">
            Contribute to cutting-edge AI research in creative generation
          </p>
        </div>

        <div className="bg-white p-6 rounded-lg shadow-sm border">
          <div className="flex flex-col items-center mb-4">
            <BookOpen className="h-10 w-10 text-green-500 mb-3" />
            <h3 className="text-xl font-semibold">Track Impact</h3>
          </div>
          <p className="text-gray-600 text-center">
            See your contribution impact on our research leaderboard
          </p>
        </div>
      </div>

      {/* How It Works */}
      <div className="grid md:grid-cols-2 gap-8">
        <div className="bg-white p-6 rounded-lg shadow-sm border">
          <h3 className="text-xl font-semibold mb-4">How It Works</h3>
          <ol className="space-y-4">
            <li className="flex gap-3">
              <span className="font-bold text-blue-600">1.</span>
              <span>View two AI-generated Minecraft builds side by side</span>
            </li>
            <li className="flex gap-3">
              <span className="font-bold text-blue-600">2.</span>
              <span>Choose which build better matches the given prompt</span>
            </li>
            <li className="flex gap-3">
              <span className="font-bold text-blue-600">3.</span>
              <span>Help improve AI models through your feedback</span>
            </li>
          </ol>
        </div>

        <div className="bg-white p-6 rounded-lg shadow-sm border">
          <h3 className="text-xl font-semibold mb-4">Why Participate?</h3>
          <ul className="space-y-4">
            <li className="flex gap-3">
              <span>üî¨</span>
              <span>Contribute to cutting-edge AI research</span>
            </li>
            <li className="flex gap-3">
              <span>üéÆ</span>
              <span>Help improve AI generation for Minecraft</span>
            </li>
            <li className="flex gap-3">
              <span>üèÜ</span>
              <span>Track your contribution impact on the leaderboard</span>
            </li>
          </ul>
        </div>
      </div>

      <AuthModal
        isOpen={isAuthModalOpen}
        onClose={() => setIsAuthModalOpen(false)}
        isLoading={false}
        mode="login"
      />
    </div>
  )
}

const COMPARISON_EXPIRY = 50 * 60 * 1000 // 50 minutes in milliseconds
const TARGET_QUEUE_SIZE = 5
const REFILL_THRESHOLD = 2

const useIsMobile = () => {
  const [isMobile, setIsMobile] = useState(false)

  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth <= 768) // You can adjust this breakpoint
    }

    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  return isMobile
}

interface WASDControlsProps {
  isActive: boolean
}

const WASDControls = ({ isActive }: WASDControlsProps) => {
  const { camera } = useThree()
  const keys = useRef({
    w: false,
    a: false,
    s: false,
    d: false,
    ' ': false,
    q: false,
  })
  const mouseDown = useRef(false)
  const lastMousePos = useRef({ x: 0, y: 0 })
  const euler = useRef(new THREE.Euler(0, 0, 0, 'YXZ'))

  useEffect(() => {
    if (!isActive) return

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key in keys.current) {
        keys.current[e.key as keyof typeof keys.current] = true
      }
    }

    const handleKeyUp = (e: KeyboardEvent) => {
      if (e.key in keys.current) {
        keys.current[e.key as keyof typeof keys.current] = false
      }
    }

    const handleMouseDown = (e: MouseEvent) => {
      mouseDown.current = true
      lastMousePos.current = { x: e.clientX, y: e.clientY }
    }

    const handleMouseUp = () => {
      mouseDown.current = false
    }

    const handleMouseMove = (e: MouseEvent) => {
      if (mouseDown.current) {
        const deltaX = e.clientX - lastMousePos.current.x
        const deltaY = e.clientY - lastMousePos.current.y

        euler.current.y -= deltaX * 0.004
        euler.current.x = Math.max(
          -Math.PI / 2,
          Math.min(Math.PI / 2, euler.current.x - deltaY * 0.004)
        )

        camera.quaternion.setFromEuler(euler.current)
        lastMousePos.current = { x: e.clientX, y: e.clientY }
      }
    }

    const resetControls = () => {
      mouseDown.current = false
      Object.keys(keys.current).forEach((key) => {
        keys.current[key as keyof typeof keys.current] = false
      })
    }

    const handleMouseLeave = () => {
      resetControls()
    }

    const canvas = document.querySelector('canvas')
    canvas?.addEventListener('mouseleave', handleMouseLeave)

    window.addEventListener('keydown', handleKeyDown)
    window.addEventListener('keyup', handleKeyUp)
    window.addEventListener('mousedown', handleMouseDown)
    window.addEventListener('mouseup', handleMouseUp)
    window.addEventListener('mousemove', handleMouseMove)

    return () => {
      window.removeEventListener('keydown', handleKeyDown)
      window.removeEventListener('keyup', handleKeyUp)
      window.removeEventListener('mousedown', handleMouseDown)
      window.removeEventListener('mouseup', handleMouseUp)
      window.removeEventListener('mousemove', handleMouseMove)
      canvas?.removeEventListener('mouseleave', handleMouseLeave)
    }
  }, [camera, isActive])

  useFrame(() => {
    if (!isActive) return

    const moveSpeed = 0.7
    if (keys.current.w) camera.translateZ(-moveSpeed)
    if (keys.current.s) camera.translateZ(moveSpeed)
    if (keys.current.a) camera.translateX(-moveSpeed)
    if (keys.current.d) camera.translateX(moveSpeed)
    if (keys.current[' ']) camera.position.y += moveSpeed // Space to go up
    if (keys.current.q) camera.position.y -= moveSpeed // Q to go down
  })

  return null
}

let cachedMetricId: string | null = null

const fetchMetricId = async (): Promise<string> => {
  if (cachedMetricId) return cachedMetricId

  const { data } = await api.get<MetricResponse[]>('/metric')
  const metric = data.find((m) => m.name === 'UNQUALIFIED_BETTER')
  if (!metric) throw new Error('Required metric not found')

  cachedMetricId = metric.id
  return metric.id
}

const getModelPath = (
  comparison: ComparisonResponse,
  sampleId: string
): string => {
  const asset = comparison.assets.find((a) => a.sampleId === sampleId)
  const gltfFile = asset?.files.find((f) => f.kind === 'gltf_scene')

  if (!gltfFile?.url) {
    console.error('Missing GLTF file for sample:', sampleId)
    throw new Error(`Missing GLTF file for sample: ${sampleId}`)
  }

  return gltfFile.url
}

const MCBench = () => {
  const { isAuthenticated } = useAuth()

  // If not authenticated, show the landing page
  if (!isAuthenticated) {
    return <UnauthenticatedView />
  }
  const isMobile = useIsMobile()

  const [metricId, setMetricId] = useState<string | null>(null)
  const [comparisons, setComparisons] = useState<QueuedComparison[]>([])
  const [currentComparison, setCurrentComparison] =
    useState<QueuedComparison | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [voted, setVoted] = useState(false)
  const viewerRefA = useRef<HTMLDivElement>(null)
  const viewerRefB = useRef<HTMLDivElement>(null)
  const dimensionsRefA = useRef<{ width: number; height: number }>()
  const dimensionsRefB = useRef<{ width: number; height: number }>()
  const [error, setError] = useState<string | null>(null)
  const [preloadStatus, setPreloadStatus] = useState<Record<string, boolean>>(
    {}
  )
  const [activeViewer, setActiveViewer] = useState<'A' | 'B' | null>(null)
  const [noComparisonsAvailable, setNoComparisonsAvailable] = useState(false)

  useEffect(() => {
    fetchMetricId()
      .then(setMetricId)
      .catch((err) =>
        setError(err instanceof Error ? err.message : 'Failed to fetch metric')
      )
  }, [])

  useEffect(() => {
    return () => {
      // Cleanup all models when component unmounts
      comparisons.forEach((comparison) => {
        comparison.samples.forEach((sampleId) => {
          const modelPath = modelPathCache.get(sampleId)
          if (modelPath) {
            cleanupModel(modelPath)
          }
        })
      })

      if (currentComparison) {
        currentComparison.samples.forEach((sampleId) => {
          const modelPath = modelPathCache.get(sampleId)
          if (modelPath) {
            cleanupModel(modelPath)
          }
        })
      }
    }
  }, [comparisons, currentComparison])

  const fetchComparisons = useCallback(async () => {
    if (!metricId) return

    try {
      const batchSize = TARGET_QUEUE_SIZE - comparisons.length
      if (batchSize <= 0) return

      const request: NewComparisonBatchRequest = {
        batchSize: batchSize,
        metricId: metricId,
      }

      const { data } = await api.post<ComparisonBatchResponse>(
        '/comparison/batch',
        request
      )

      if (data.comparisons.length === 0) {
        setNoComparisonsAvailable(true)
        setIsLoading(false)
        return
      }

      const newComparisons: QueuedComparison[] = data.comparisons.map(
        (comp) => ({
          ...comp,
          fetchedAt: Date.now(),
        })
      )

      setComparisons((prev) => [...prev, ...newComparisons])
    } catch (err) {
      setError(
        err instanceof Error ? err.message : 'Failed to fetch comparisons'
      )
    }
  }, [comparisons.length, metricId])

  const submitComparison = async (winningId: string) => {
    if (!currentComparison) return

    try {
      const orderedSampleIds =
        winningId === currentComparison.samples[0]
          ? currentComparison.samples
          : currentComparison.samples.slice().reverse()

      const payload: UserComparisonRequest = {
        comparisonDetails: {
          token: currentComparison.token,
          samples: currentComparison.samples,
        },
        orderedSampleIds,
      }

      console.log('Submitting vote: ', payload)

      await api.post('/comparison/result', payload)
    } catch (err) {
      console.error('Failed to submit comparison:', err)
      // Continue to next comparison even if submission fails
    }
  }

  useEffect(() => {
    const now = Date.now()

    const validComparisons = comparisons.filter(
      (comp) => now - comp.fetchedAt < COMPARISON_EXPIRY
    )

    if (validComparisons.length !== comparisons.length) {
      setComparisons(validComparisons)
      console.log('Valid Comparisons Remaining', validComparisons.length)
    }

    if (validComparisons.length <= REFILL_THRESHOLD) {
      fetchComparisons()
    }

    if (!currentComparison && validComparisons.length > 0) {
      setCurrentComparison(validComparisons[0])
      setComparisons(validComparisons.slice(1))
      setVoted(false)
      setIsLoading(false)
    }
  }, [comparisons, currentComparison, fetchComparisons])

  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (voted || !currentComparison) return

      if (event.key === 'ArrowLeft') {
        handleVote('A')
      } else if (event.key === 'ArrowRight') {
        handleVote('B')
      }
    }

    window.addEventListener('keydown', handleKeyPress)
    return () => window.removeEventListener('keydown', handleKeyPress)
  }, [voted, currentComparison])

  const handleVote = async (choice: 'A' | 'B') => {
    if (!currentComparison || voted) return

    setVoted(true)
    const winningId = currentComparison.samples[choice === 'A' ? 0 : 1]
    await submitComparison(winningId)
  }

  const handleNext = () => {
    if (currentComparison) {
      console.log('Starting cleanup for next comparison')
      currentComparison.samples.forEach((sampleId) => {
        const modelPath = modelPathCache.get(sampleId)
        if (modelPath) {
          console.log(
            'Cleaning up model for sampleId:',
            sampleId,
            'path:',
            modelPath
          )
          cleanupModel(modelPath)
        }
      })
    }
    setCurrentComparison(null)
    setVoted(false)
  }

  // In MCBench.tsx
  const preloadUpcomingModels = useCallback(async () => {
    if (!currentComparison) return

    console.log('Starting preload for models')

    // Get paths and preload current comparison models
    const modelAPath = getModelPath(
      currentComparison,
      currentComparison.samples[0]
    )
    const modelBPath = getModelPath(
      currentComparison,
      currentComparison.samples[1]
    )

    try {
      await Promise.all([preloadModel(modelAPath), preloadModel(modelBPath)])

      // Only update preload status after successful load
      setPreloadStatus((prev) => ({
        ...prev,
        [currentComparison.samples[0]]: true,
        [currentComparison.samples[1]]: true,
      }))

      console.log('Preload complete for current models')

      // Also preload next comparison if available
      if (comparisons.length > 0) {
        const nextComparison = comparisons[0]
        const nextPaths = nextComparison.samples.map((sampleId) =>
          getModelPath(nextComparison, sampleId)
        )

        // Preload next models in background
        Promise.all(nextPaths.map(preloadModel)).then(() => {
          setPreloadStatus((prev) => ({
            ...prev,
            [nextComparison.samples[0]]: true,
            [nextComparison.samples[1]]: true,
          }))
          console.log('Preload complete for next models')
        })
      }
    } catch (error) {
      console.error('Error preloading models:', error)
    }
  }, [currentComparison, comparisons])

  useEffect(() => {
    preloadUpcomingModels()
  }, [currentComparison, preloadUpcomingModels])

  if (error) {
    return (
      <div className="flex justify-center items-center h-[400px] text-red-600">
        {error}
      </div>
    )
  }

  // Add loading indicator while models are preloading
  if (
    isLoading ||
    (currentComparison &&
      !preloadStatus[currentComparison.samples[0]] &&
      !preloadStatus[currentComparison.samples[1]])
  ) {
    return (
      <div className="flex justify-center items-center h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    )
  }

  if (noComparisonsAvailable) {
    return (
      <div className="flex justify-center items-center h-[400px] text-gray-600">
        No comparisons available at this time. Please check back later.
      </div>
    )
  }

  if (
    !currentComparison ||
    !preloadStatus[currentComparison.samples[0]] ||
    !preloadStatus[currentComparison.samples[1]]
  ) {
    return (
      <div className="flex justify-center items-center h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    )
  }

  // Get the paths directly since we know preload is complete
  const modelAPath = getModelPath(
    currentComparison,
    currentComparison.samples[0]
  )
  const modelBPath = getModelPath(
    currentComparison,
    currentComparison.samples[1]
  )

  const buildPair: BuildPair = {
    prompt: currentComparison.buildDescription,
    modelA: {
      name: 'Model A',
      modelPath: modelAPath,
      sampleId: currentComparison.samples[0],
      stats: {
        blocksUsed: 123,
        timeTaken: '12.3s',
      },
    },
    modelB: {
      name: 'Model B',
      modelPath: modelBPath,
      sampleId: currentComparison.samples[1],
      stats: {
        blocksUsed: 135,
        timeTaken: '13.5s',
      },
    },
  }

  const handleFullscreen = (
    ref: React.RefObject<HTMLDivElement>,
    dimensionsRef: React.MutableRefObject<
      { width: number; height: number } | undefined
    >
  ) => {
    if (!ref.current) return

    if (document.fullscreenElement) {
      document.exitFullscreen().then(() => {
        if (ref.current && dimensionsRef.current) {
          ref.current.style.width = `${dimensionsRef.current.width}px`
          ref.current.style.height = `${dimensionsRef.current.height}px`
        }
      })
    } else {
      dimensionsRef.current = {
        width: ref.current.offsetWidth,
        height: ref.current.offsetHeight,
      }
      ref.current.requestFullscreen()
    }
  }

  if (
    !preloadStatus[currentComparison.samples[0]] ||
    !preloadStatus[currentComparison.samples[1]]
  ) {
    return (
      <div className="flex justify-center items-center h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    )
  }

  return (
    <div className="max-w-6xl mx-auto p-4 space-y-6">
      <div className="text-center space-y-2">
        <h1 className="text-3xl font-bold">MC-Bench</h1>
        <p className="text-gray-600">
          Which AI generated this Minecraft build better?
        </p>
      </div>

      <div className="bg-white rounded-lg shadow-sm border p-4">
        <div className="flex justify-between items-center">
          <span className="text-sm font-medium text-gray-600">Prompt</span>
        </div>
        <div className="mt-2">
          <div className="bg-blue-50 text-blue-900 p-3 rounded-md text-center text-lg">
            {buildPair.prompt}
          </div>
        </div>
      </div>

      <div className="space-y-4">
        <div className="flex flex-col md:flex-row gap-4 bg-white">
          {[buildPair.modelA, buildPair.modelB].map((model, idx) => (
            <div
              key={idx}
              ref={idx === 0 ? viewerRefA : viewerRefB}
              className="relative w-full md:flex-1 h-[400px] overflow-hidden bg-green-50 rounded-lg"
              onMouseEnter={() =>
                !isMobile && setActiveViewer(idx === 0 ? 'A' : 'B')
              }
              onMouseLeave={() => !isMobile && setActiveViewer(null)}
            >
              <div className="absolute top-2 right-2 z-10">
                <button
                  onClick={() =>
                    handleFullscreen(
                      idx === 0 ? viewerRefA : viewerRefB,
                      idx === 0 ? dimensionsRefA : dimensionsRefB
                    )
                  }
                  className="bg-black/75 text-white p-2 rounded-md w-8 h-8 flex items-center justify-center hover:bg-black/90"
                >
                  <Maximize2 className="h-4 w-4" />
                </button>
              </div>
              <div className="absolute bottom-2 left-2 z-10">
                <div className="bg-black/75 text-white px-2 py-2 rounded-md text-sm w-8 h-8 flex items-center justify-center">
                  {idx === 0 ? 'A' : 'B'}
                </div>
              </div>
              <Canvas
                camera={{
                  position: [30, 5, 30],
                  fov: 60,
                }}
              >
                <Background />
                <Suspense fallback={null}>
                  <Model path={model.modelPath} />
                  {isMobile ? (
                    <OrbitControls
                      enableZoom={true}
                      minDistance={1}
                      maxDistance={100}
                      target={[0, 0, 0]}
                    />
                  ) : (
                    <WASDControls
                      isActive={activeViewer === (idx === 0 ? 'A' : 'B')}
                    />
                  )}
                </Suspense>
              </Canvas>
              {voted && (
                <div className="absolute top-2 left-2">
                  <div className="bg-black/75 text-white px-3 py-1 rounded-md text-sm">
                    {model.name}
                  </div>
                </div>
              )}
            </div>
          ))}
        </div>

        {!voted ? (
          <div className="flex flex-col md:grid md:grid-cols-2 gap-4">
            <button
              onClick={() => handleVote('A')}
              className="w-full bg-gray-900 hover:bg-gray-800 text-white py-3 rounded-md"
            >
              Vote A
            </button>
            <button
              onClick={() => handleVote('B')}
              className="w-full bg-gray-900 hover:bg-gray-800 text-white py-3 rounded-md"
            >
              Vote B
            </button>
          </div>
        ) : (
          <div className="space-y-4">
            <div className="flex flex-col md:flex-row gap-4">
              {[buildPair.modelA, buildPair.modelB].map((model, idx) => (
                <div
                  key={idx}
                  className="flex-1 bg-white rounded-lg shadow-sm border p-4"
                >
                  <div className="grid grid-cols-2 gap-4 text-sm">
                    <div className="text-center">
                      <div className="font-semibold">Blocks</div>
                      <div>{model.stats.blocksUsed}</div>
                    </div>
                    <div className="text-center">
                      <div className="font-semibold">Time</div>
                      <div>{model.stats.timeTaken}</div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
            <button
              onClick={handleNext}
              className="w-full bg-blue-500 hover:bg-blue-600 text-white py-3 rounded-md"
            >
              Next Comparison
            </button>
          </div>
        )}

        <div className="flex justify-center gap-2 pt-4">
          <button className="p-2 rounded-full border hover:bg-gray-100">
            <Share2 className="h-4 w-4" />
          </button>
          <button className="p-2 rounded-full border hover:bg-gray-100">
            <Flag className="h-4 w-4" />
          </button>
        </div>
      </div>
    </div>
  )
}

export default MCBench
